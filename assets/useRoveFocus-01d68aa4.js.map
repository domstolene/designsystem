{"version":3,"file":"useRoveFocus-01d68aa4.js","sources":["../../../../packages/components/src/hooks/useRoveFocus.tsx"],"sourcesContent":["import {\n  useCallback,\n  useState,\n  useEffect,\n  Dispatch,\n  SetStateAction,\n  KeyboardEvent,\n} from 'react';\nimport { Direction } from '../types';\n\nexport const isKeyboardEvent = (\n  e: Event | KeyboardEvent<Element>\n): e is KeyboardEvent<Element> =>\n  (e as KeyboardEvent<Element>).key !== undefined;\n\n/**\n * Bytter fokus mellom elementer i en gruppe med piltaster og ikke Tab, og looper fokus i gruppen. Typisk bruk:\n * ```\n * import elements from './elements';\n * import RoveItem from './RoveItem';\n *\n * const MyComponent = () => {\n *  const [focus, setFocus] = useRoveFocus(elements.length);\n *\n *  return (\n *  <ul>\n *    {elements.map((element, index) => (\n *    <li key={element}>\n *      <RoveItem index={index} focus={focus === index} setFocus={setFocus}>{element.name}</RoveItem>\n *    </li>\n *    ))}\n *  </ul>)\n * }\n * ```\n * @param size antall elementer i gruppen.\n * @param reset om fokus i gruppen skal nullstilles; når man tabber seg inn i gruppen skal focus være nullstilt.\n * @param direction retning elementene blas i.\n * @returns hook par: indeksen til fokuserte elemenentet og funksjonen som håndterer fokus.\n */\n\nexport function useRoveFocus(\n  size?: number,\n  reset?: boolean,\n  direction: Direction = 'column'\n): [number, Dispatch<SetStateAction<number>>] {\n  const [currentFocusIndex, setCurrentFocusIndex] = useState(-1);\n\n  const nextKey = direction === 'row' ? 'ArrowRight' : 'ArrowDown';\n  const previousKey = direction === 'row' ? 'ArrowLeft' : 'ArrowUp';\n\n  const handleKeyDown = useCallback(\n    (e: Event) => {\n      if (!size || !isKeyboardEvent(e)) return;\n      if (reset) setCurrentFocusIndex(-1);\n      if (e.key === nextKey) {\n        // Down arrow\n        e.preventDefault();\n        setCurrentFocusIndex(\n          currentFocusIndex === size - 1 ? 0 : currentFocusIndex + 1\n        );\n      } else if (e.key === previousKey) {\n        // Up arrow\n        e.preventDefault();\n        if (currentFocusIndex !== -1) {\n          setCurrentFocusIndex(\n            currentFocusIndex === 0 ? size - 1 : currentFocusIndex - 1\n          );\n        } else setCurrentFocusIndex(size - 1);\n      }\n    },\n    [size, currentFocusIndex, setCurrentFocusIndex, reset]\n  );\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown, false);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, false);\n    };\n  }, [handleKeyDown]);\n\n  return [currentFocusIndex, setCurrentFocusIndex];\n}\n"],"names":["isKeyboardEvent","useRoveFocus","size","reset","direction","currentFocusIndex","setCurrentFocusIndex","useState","nextKey","previousKey","handleKeyDown","useCallback","e","useEffect"],"mappings":"wCAUO,MAAMA,EACX,GAEC,EAA6B,MAAQ,OA2BjC,SAASC,EACdC,EACAC,EACAC,EAAuB,SACqB,CAC5C,KAAM,CAACC,EAAmBC,CAAoB,EAAIC,EAAAA,SAAS,EAAE,EAEvDC,EAAUJ,IAAc,MAAQ,aAAe,YAC/CK,EAAcL,IAAc,MAAQ,YAAc,UAElDM,EAAgBC,EAAA,YACnBC,GAAa,CACR,CAACV,GAAQ,CAACF,EAAgBY,CAAC,IAC3BT,GAAOG,EAAqB,EAAE,EAC9BM,EAAE,MAAQJ,GAEZI,EAAE,eAAe,EACjBN,EACED,IAAsBH,EAAO,EAAI,EAAIG,EAAoB,CAAA,GAElDO,EAAE,MAAQH,IAEnBG,EAAE,eAAe,EAEfN,EADED,IAAsB,GAEtBA,IAAsB,EAAIH,EAAO,EAAIG,EAAoB,EAEjCH,EAAO,CAF0B,GAIjE,EACA,CAACA,EAAMG,EAAmBC,EAAsBH,CAAK,CAAA,EAGvDU,OAAAA,EAAAA,UAAU,KACC,SAAA,iBAAiB,UAAWH,EAAe,EAAK,EAClD,IAAM,CACF,SAAA,oBAAoB,UAAWA,EAAe,EAAK,CAAA,GAE7D,CAACA,CAAa,CAAC,EAEX,CAACL,EAAmBC,CAAoB,CACjD"}